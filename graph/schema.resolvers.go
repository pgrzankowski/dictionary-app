package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/pgrzankowski/dictionary-app/db"
	"github.com/pgrzankowski/dictionary-app/graph/model"
	"github.com/pgrzankowski/dictionary-app/models"
	gormModels "github.com/pgrzankowski/dictionary-app/models"
)

// CreateTranslation is the resolver for the createTranslation field.
func (r *mutationResolver) CreateTranslation(ctx context.Context, input model.NewTranslationInput) (*model.Translation, error) {
	transaction := db.GormDB.Begin()
	if transaction.Error != nil {
		return nil, transaction.Error
	}

	var polishWord gormModels.PolishWord
	if err := transaction.Where("word = ?", input.PolishWord).
		FirstOrCreate(&polishWord, gormModels.PolishWord{Word: input.PolishWord}).
		Error; err != nil {
		transaction.Rollback()
		return nil, fmt.Errorf("failed to get or create polish word: %w", err)
	}

	translation := gormModels.Translation{
		EnglishWord:  input.EnglishWord,
		PolishWordID: polishWord.ID,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}
	if err := transaction.Create(&translation).Error; err != nil {
		transaction.Rollback()
		return nil, fmt.Errorf("failed to create translation: %w", err)
	}

	for _, exInput := range input.Examples {
		example := gormModels.Example{
			Sentence:      exInput.Sentence,
			TranslationID: translation.ID,
			CreatedAt:     time.Now(),
			UpdatedAt:     time.Now(),
		}
		if err := transaction.Create(&example).Error; err != nil {
			transaction.Rollback()
			return nil, fmt.Errorf("failed to create example: %w", err)
		}
		translation.Examples = append(translation.Examples, example)
	}

	if err := transaction.Commit().Error; err != nil {
		return nil, err
	}

	transaction.Model(&translation).Association("PolishWord").Find(&translation.PolishWord)

	return &model.Translation{
		ID:          strconv.Itoa(int(translation.ID)),
		EnglishWord: translation.EnglishWord,
		CreatedAt:   translation.CreatedAt.String(),
		UpdatedAt:   translation.UpdatedAt.String(),
		PolishWord: &model.PolishWord{
			ID:        strconv.Itoa(int(polishWord.ID)),
			Word:      polishWord.Word,
			CreatedAt: polishWord.CreatedAt.String(),
			UpdatedAt: polishWord.UpdatedAt.String(),
		},
		Examples: convertExamples(translation.Examples),
	}, nil
}

func convertExamples(examples []gormModels.Example) []*model.Example {
	var result []*model.Example
	for _, ex := range examples {
		result = append(result, &model.Example{
			ID:        strconv.Itoa(int(ex.ID)),
			Sentence:  ex.Sentence,
			CreatedAt: ex.CreatedAt.String(),
			UpdatedAt: ex.UpdatedAt.String(),
		})
	}
	return result
}

// RemoveTranslation is the resolver for the removeTranslation field.
func (r *mutationResolver) RemoveTranslation(ctx context.Context, id string) (bool, error) {
	intID, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("invalid id format: %w", err)
	}

	transaction := db.GormDB.Begin()
	if transaction.Error != nil {
		return false, transaction.Error
	}

	var translation models.Translation
	if err := transaction.
		Preload("PolishWord").
		First(&translation, intID).
		Error; err != nil {
		transaction.Rollback()
		return false, err
	}

	polishWordID := translation.PolishWordID

	if err := transaction.Delete(&translation).Error; err != nil {
		transaction.Rollback()
		return false, err
	}

	var translationCount int64
	if err := transaction.Model(&models.Translation{}).
		Where("polish_word_id = ?", polishWordID).
		Count(&translationCount).Error; err != nil {
		transaction.Rollback()
		return false, err
	}

	if translationCount == 0 {
		if err := transaction.Delete(&models.PolishWord{}, polishWordID).
			Error; err != nil {
			transaction.Rollback()
			return false, nil
		}
	}

	if err := transaction.Commit().Error; err != nil {
		return false, err
	}

	return true, nil
}

// UpdateTranslation is the resolver for the updateTranslation field.
func (r *mutationResolver) UpdateTranslation(ctx context.Context, input model.UpdateTranslationInput) (*model.Translation, error) {
	intID, err := strconv.Atoi(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid id: %v", err)
	}

	if input.EnglishWord != nil {
		_, err := db.DB.ExecContext(ctx,
			"UPDATE translations SET english_word = $1, updated_at = NOW() WHERE id = $2",
			*input.EnglishWord, intID)
		if err != nil {
			return nil, err
		}
	}

	var englishWord string
	var createdAt, updatedAt time.Time
	err = db.DB.QueryRowContext(ctx,
		"SELECT english_word, created_at, updated_at FROM translations WHERE id = $1", intID).
		Scan(&englishWord, &createdAt, &updatedAt)
	if err != nil {
		return nil, err
	}

	return &model.Translation{
		ID:          input.ID,
		EnglishWord: englishWord,
		CreatedAt:   createdAt.String(),
		UpdatedAt:   updatedAt.String(),
	}, nil
}

// Translations is the resolver for the translations field.
func (r *queryResolver) Translations(ctx context.Context) ([]*model.Translation, error) {
	var translations []models.Translation
	if err := db.GormDB.
		Preload("PolishWord").
		Preload("Examples").
		Find(&translations).Error; err != nil {
		return nil, err
	}

	var result []*model.Translation
	for _, translation := range translations {
		result = append(result, &model.Translation{
			ID:          strconv.Itoa(int(translation.ID)),
			EnglishWord: translation.EnglishWord,
			CreatedAt:   translation.CreatedAt.String(),
			UpdatedAt:   translation.UpdatedAt.String(),
			PolishWord: &model.PolishWord{
				ID:        strconv.Itoa(int(translation.PolishWord.ID)),
				Word:      translation.PolishWord.Word,
				CreatedAt: translation.PolishWord.CreatedAt.String(),
				UpdatedAt: translation.PolishWord.UpdatedAt.String(),
			},
			Examples: convertExamples(translation.Examples),
		})
	}

	return result, nil
}

// Translation is the resolver for the translation field.
func (r *queryResolver) Translation(ctx context.Context, id string) (*model.Translation, error) {
	intID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid id format: %v", err)
	}

	var translation models.Translation
	if err := db.GormDB.
		Preload("PolishWord").
		Preload("Examples").
		First(&translation, intID).Error; err != nil {
		return nil, err
	}

	result := &model.Translation{
		ID:          strconv.Itoa(int(translation.ID)),
		EnglishWord: translation.EnglishWord,
		CreatedAt:   translation.CreatedAt.String(),
		UpdatedAt:   translation.UpdatedAt.String(),
		PolishWord: &model.PolishWord{
			ID:        strconv.Itoa(int(translation.PolishWord.ID)),
			Word:      translation.PolishWord.Word,
			CreatedAt: translation.PolishWord.CreatedAt.String(),
			UpdatedAt: translation.PolishWord.UpdatedAt.String(),
		},
		Examples: convertExamples(translation.Examples),
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
